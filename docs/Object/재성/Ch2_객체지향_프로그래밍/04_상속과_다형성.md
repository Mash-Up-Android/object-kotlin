```kotlin

class Movie(
    private val title: String,
    private val runningTime: Duration,
    private val fee: Money,
    private val discountPolicy: DiscountPolicy,
) {

    fun getFee(): Money {
        return fee
    }

    fun calculateMovieFee(screening: Screening): Money {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening))
    }
}
```

Movie에서 영화 요금을 개산하기 위해서는 DiscountPolicy가 필요한데 DiscountPolicy는 추상클래스라 어떤 Policy를 따라갈지는 런타임에 결정되어야 함

코드레벨에서는 PercentPolicy나 AmountPolicy를 의존하지 않고 추상화에만 의존하고 있음

즉, 코드의 의존성과 실행시점의 의존성이 서로 다를 수 있다는 것을 의미함

→ 클래스 사이의 의존성과 객체 사이의 의존성이 동일하지 않을 수 있다

실질적으로는 Movie ↔ DiscountPolicy 간의 객체간 의존성으로 구성되지만 런타임에 따라 클래스 의존성이 달라짐

이렇게 다르게 되면 코드 이해가 어려울수도 있음. 이건 트레이드오프다

이렇게 유연하게 설계를 하는 것은 코드를 이해하기 어려울수도 있고 디버깅하기 어려울수도 있음

하지만 유연성을 억제하면 재사용성과 확장성이 떨어질 수 있음

무조건 유연한 설계도, 읽기쉬운 코드도 정답은 아니다~ (요게 핵심)

클래스 하나를 추가하는데 거의 비슷하다? 약간만 추가하거나 수정하면 되는데..?

이때 사용하는게 상속

모든 인터페이스를 자식 클래스가 물려받을 수 있다는게 장점

상속이 단순히 재사용에 초점이 되는건 아니다~

Movie가 DiscountPolicy에 전달하는 calculateDiscountAmount 메시지를 통해 DiscountPolicy는 내부에서 처리할 메서드를 선택함

즉, 동일한 메시지를 전달하지만 어떤 메서드가 실행될지는 메시지를 수신하는 객체 클래스가 뭐냐에 따라 달라진다.

이게 다형성~

다형성을 활용하면 메시지와 메서드가 동적 바인딩이 되고, 사용하지 않으면 정적 바인딩으로 동작됨