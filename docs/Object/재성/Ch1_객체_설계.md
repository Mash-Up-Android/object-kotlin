## 1. 티켓 판매 애플리케이션 구현
![img.png](../../../../assets/재성/img.png)

이 클래스 다이어그램이 객체지향을 설명하기에 가장 근간이 될 것 같은 느낌

Audience, Bag, TicketSeller, TicketOffice 등등으로 각 객체가 가져야할 역할과 책임들이 분리되어있고 필요시에 의존성을 통해 상호작용 하는 느낌? (getBag나 getTicketOffice 처럼)

라고 생각했는데 문제가 있다네 ㅋㅋ ^^!!

## 2. 무엇이 문제인가
모듈의 목적은 세가지이다.

1. 런타임에 문제없이 동작한다.
2. 변경을 위해 존재한다.
3. 개발자가 이해하기 쉽게 작성되어야 한다.

Theater 클래스의 enter 메서드는 Audience와 TicketSeller가 Theater에 강한 의존성으로 엮여있어 예측 가능한 범주내에서 동작되지 않을 수 있다.

이렇게 작성되면 이해하는 사람마다 예상하는 동작 방향이 다를 수 있기 때문에 의사소통에 제한이 생김

세부내용들을 다 기억할 수 있어야 코드 흐름 파악이 가능하다는 문제도 생김

Audience와 TicketSeller를 변경하면 Theater도 함께 변경되어야 한다는 문제가 가장 큰 이슈

변경에 취약한 코드는 객체간의 강한 의존성 (coupling)이 걸릴 수록 더 문제가 생긴다

의존성은 변경과 관련이 있다.

객체에 변경이 생길 때 그 객체를 의존하는 객체도 함께 변경될 수 있다.

객체사이의 의존성을 없애는 것이 해답이 아니라 최소한의 의존성만을 유지하는게 목표

객체지향 설계는 서로 의존하며 협력하는 객체들의 공동체를 구축하는 것

## 3. 설계 개선하기
앞선 예시들은 Audience와 TicketSeller의 책임이 다른 객체에 의해 제어된다는 것이 예상 범주내에서 벗어나기 때문에 문제가 될 수 있었음

Audience와 TicketSeller가 Theater객체에 강하게 결합되기 때문

Audience와 TicketSeller가 변경되면 Theater도 변경해야 하는 잠재적 문제가 발생될 수 있음

해결법

Audience와 TicketSeller에 대한 정보은닉

자율적인 객체로 두면 됨

Theater#enter 메서드 리팩토링

기존 Theater에서 TicketOffice에 접근하는 로직을 제거하고 TicketSeller의 책임으로 이동 (캡슐화)

변경된 코드에서는 Theater는 TicketOffice에 대한 의존성을 갖지 않게 됨

Theater에 진입하기 위한 방법은 ticketSeller의 sellTo 메시지를 통한 것만 알게됨

Theater는 TicketSeller 인터페이스만 의존, TicketSeller가 내부에 TicketOffice를 포함하는 것은 구현체에 해당

객체를 인터페이스와 구현체로 나누어 다른 객체와 소통하는 매개체인 인터페이스만 공개하는 것은 객체 지향 기본 설계 원칙에 해당

TicketSeller에서 Audience에 대한 의존마저 분리하게 되면 Audience의 buy에 대한 구현이 변경되더라도 TicketSeller에 영향을 미치지 않게됨

최종 설계

![img.png](../../../../assets/재성/img01.png)

기존 설계

![img.png](../../../../assets/재성/img02.png)

설계를 변경하게 되면 Audience가 bag을 소지하는게 아니라 다른걸 소지하더라도 변경이 전달되지 않게 됨

기존 코드에서는 Theater가 Audience와 TicketOffice에 대한 모든 구현을 알고있어야 했고 강하게 결합되어 있었지만 변경하게 되면 Theater가 Audience와 TicketOffice의 내부에 직접 접근하지 않게 됨

객체의 자율성을 높이게 된다

객체가 가져야할 책임을 높이고 연관성 없는 작업을 다른 객체에 위임함으로서 응집도를 높일 수 있게 됨

객체간의 결합도는 낮추고 단일 객체의 응집도를 높이는게 중요해 보임!

Q. 객체간의 결합도는 낮출 수 있겠지만 객체 안에서의 메서드끼리의 결합도는 어떻게 낮출 수 있을까?

기존 코드에서는 Theater가 모든 객체들에 의존하기 때문에 이걸 절차적 프로그래밍이라고 한다네

절차적 프로그래밍은 변경하기 어려운 코드를 양상하기도 함

변경하기 쉬운 설계는 한번에 하나의 클래스만 변경할 수 있는 설계이다.

캡슐화를 통해 의존성을 적절히 관리함으로서 객체간의 결합도를 낮추는게 훌륭한 객체 지향 설계다~

![img.png](../../../../assets/재성/img03.png)

객체는 다른 객체와 협력하기 위한 적절한 책임을 가져야 한다

이를 위해 적절히 책임을 이동시킬 필요도 있고, 정확히는 객체에 어떤 책임을 할당할지를 잘 생각하면서 설계하는게 좋다

## 4. 객체지향 설계
좋은 설계란 기능 동작이 정상적으로 되어야 하고, 유지보수하기도 쉬워야 한다

변경에 유연하게 대응할 수 있는 코드를 작성하는 것이 중요하다

객체지향은 의존성을 효율적으로 통제할 수 있기 때문에 요구사항 변경에 수월하게 대응할 수 있는 가능성을 제공한다

결국 변경 가능하며 읽기 쉬운 코드를 작성하는게 중요

프로세스를 두고 그 프로세스가 다 제어하게 두는게 아니라 객체안에 프로세스와 데이터를 모아 자율적으로 협력할 수 있도록 하는게 바람직하다~