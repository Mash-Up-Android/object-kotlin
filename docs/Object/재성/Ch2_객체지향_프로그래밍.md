## 1. 영화 예매 시스템
![img.png](../../../../assets/재성/img04.png)

이런 정책들이 있다~

할인 조건들로 먼저 할인이 가능한지 판단하고 안맞으면 할인 정책으로 적용

## 2. 객체지향 프로그래밍을 향해
### **협력, 객체, 클래스**

클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 결정하는 행위는 잘못된거다.

객체지향은 말 그대로 객체를 지향하는 것.

어떤 클래스가 필요한지를 고민하기 전에 어떤 객체가 필요한지를 고민해야 한다.

객체가 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

객체는 독립적인 존재로 볼게 아니라 협력하는 구성원 중 하나로 봐야한다.

객체의 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 기반해서 클래스를 구현해야 한다.

### 도메인의 구조를 따르는 프로그램 구조

도메인은 문제 해결을 위한 프로그램 사용 분야

객체지향의 추상화 기법을 통해 도메인을 구성하는 개념들이 프로그램 상의 객체와 클래스로 연결될 수 있다.

![img.png](../../../../assets/재성/img05.png)
영화는 여러번 상영되지만 상영할때는 영화 하나만 상영하게 된다.

일반적으로 클래스 이름은 대응되는 도메인 개념 이름으로 짓는다

### 클래스 구현하기

클래스는 내부, 외부로 구분해 어떤 부분은 외부로 공개하고 어떤 부분을 캡슐화할지 결정하는게 중요한 요소

내부 외부로 구분하는 건 객체의 자율성을 보장하기 때문 → 구현의 자유를 준다

Screening 클래스에서는 public 메서드를 통해 내부 상태를 변경할 수 있게 함

*자율적인 객체*

객체는 상태와 행동을 가짐

객체는 스스로 판단하고 행동하는 자율적인 존재

과거에는 데이터와 기능이라는 독립적 존재를 서로 엮어서 프로그램을 구성했지만, 객체지향에서는 객체 단위 안에 데이터와 기능을 한 덩어리로 묶어서 표현한다. → 캡슐화와 관련

객체지향에서는 외부의 접근을 통제하고 객체를 자율적인 존재로 만드는 접근 제한자도 중요한 요소중 하나

캡슐화와 접근 제어는 객체를 두 부분으로 나누게 됨

외부에서 접근 가능한 부분은 인터페이스, 내부에서만 접근 가능한 부분은 구현이라고 부름

공개 가능한 부분만 public, 감춰야 하는 부분은 private으로 지정해야함

즉, 인터페이스는 public 메서드만 존재하게 된다.

*프로그래머의 자유*

클라이언트 프로그래머랑 클래스 작성자로 구분하는 것 같은데 내 생각에는 클라 프로그래머가 그냥 서비스 개발자, 클래스 작성자가 SDK 개발이나 core단만 만지는 개발자겠지?

클래스 작성자는 클라개발자의 잘못된 사용으로 내부 구현에 영향가지 않도록 구현은닉을 잘 해야한다~

클래스 작성자는 public 영역을 변경하지 않는 선에서 코드를 자유롭게 수정할수도 있다.

클라이언트 프로그래머는 public 영역만 알아도 되기 때문에 지식양을 줄일 수 있음

객체지향 설계는 변경을 관리하기 위해서라도 중요하다

변경을 관리하는 기법중에서 대표적인게 접근제한자다~

### 협력

객체는 다른 객체의 인터페이스에 특정 행동을 수행하도록 요청 (메시지 전송)

요청받은 (메시지 수신) 객체는 자율적 방법에따라 요청을 처리 후 응답

메시지를 수신한 객체가 자율적으로 메시지를 처리할 방법을 결정, 메서드를 통해 처리한다

**Q. 수신하기 위해 public interface 메서드를 열어두고 그거에 대한 구현이 있을 텐데, 여기서 말하는 메서드가 public interface 메서드의 구현 메서드인지 아니면 구현 메서드 안에 또 다른 메서드인지? 후자일 것 같긴함**

## 3. 할인 요금 구하기
```kotlin
fun calculateMovieFee(screening: Screening): Money {
      return fee.minus(discountPolicy.calculateDiscountAmount(screening))
}
```

여기서 중요한 점은 어떤 할인 정책을 사용할지에 대한 결정이 없다는 점

DiscountPolicy에 할인 요금에 대한 메시지를 보내면 알아서 할인 정책을 처리하도록 하는 것

## 4. 상속과 다형성
```kotlin

class Movie(
    private val title: String,
    private val runningTime: Duration,
    private val fee: Money,
    private val discountPolicy: DiscountPolicy,
) {

    fun getFee(): Money {
        return fee
    }

    fun calculateMovieFee(screening: Screening): Money {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening))
    }
}
```

Movie에서 영화 요금을 개산하기 위해서는 DiscountPolicy가 필요한데 DiscountPolicy는 추상클래스라 어떤 Policy를 따라갈지는 런타임에 결정되어야 함

코드레벨에서는 PercentPolicy나 AmountPolicy를 의존하지 않고 추상화에만 의존하고 있음

즉, 코드의 의존성과 실행시점의 의존성이 서로 다를 수 있다는 것을 의미함

→ 클래스 사이의 의존성과 객체 사이의 의존성이 동일하지 않을 수 있다

실질적으로는 Movie ↔ DiscountPolicy 간의 객체간 의존성으로 구성되지만 런타임에 따라 클래스 의존성이 달라짐

이렇게 다르게 되면 코드 이해가 어려울수도 있음. 이건 트레이드오프다

이렇게 유연하게 설계를 하는 것은 코드를 이해하기 어려울수도 있고 디버깅하기 어려울수도 있음

하지만 유연성을 억제하면 재사용성과 확장성이 떨어질 수 있음

무조건 유연한 설계도, 읽기쉬운 코드도 정답은 아니다~ (요게 핵심)

클래스 하나를 추가하는데 거의 비슷하다? 약간만 추가하거나 수정하면 되는데..?

이때 사용하는게 상속

모든 인터페이스를 자식 클래스가 물려받을 수 있다는게 장점

상속이 단순히 재사용에 초점이 되는건 아니다~

Movie가 DiscountPolicy에 전달하는 calculateDiscountAmount 메시지를 통해 DiscountPolicy는 내부에서 처리할 메서드를 선택함

즉, 동일한 메시지를 전달하지만 어떤 메서드가 실행될지는 메시지를 수신하는 객체 클래스가 뭐냐에 따라 달라진다.

이게 다형성~

다형성을 활용하면 메시지와 메서드가 동적 바인딩이 되고, 사용하지 않으면 정적 바인딩으로 동작됨

## 5. 추상화와 유연성
![img.png](../../../../assets/재성/img06.png)

영화 요금을 계산하기 위해서는 DiscountPolicy를 따라야 하고, DiscountCondition을 만족하냐 안하냐에 따라 할인 금액이 결정된다.

DiscountPolicy, DiscountCondition 모두 추상화된 개념인데 이렇게 일반적인 개념들을 통해 표현될 수 있음

<br></br>
추상화를 통해 세부 구현은 무시하고 상위 개념으로도 도메인의 중요 부분들을 설명할 수 있다

기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

두가지 특징 다 유연한 설계에 대한 내용

<br></br>
책에 나온 NonDiscountPolicy를 추가하는 것만으로도 기존 코드 수정없이 기능 확장이 가능해짐
![img.png](../../../../assets/재성/img07.png)

<br></br>
더 추상화를 진행한다면 DiscountPolicy에 개념적으로 NoneDiscountPolicy의 내용이 들어가있기 떄문에 추상화 뎁스를 한단계 추가해서 분리시킬 수 있음
![img.png](../../../../assets/재성/img08.png)

<br></br>
상속은 코드 재사용을 위해 사용되지만 캡슐화를 위반할 수도 있고 설계를 유연하게 하지 못할수도 있음

부모클래스 내부 구조를 잘 알고 있어야 하고, 부모 클래스 구현이 자식 클래스에 그대로 노출되기 때문에 변경의 여파가 그대로 전달될수도 있게 됨

과도한 상속은 오히려 변경에 어려움을 줄수도 있게 됨

또, 부모 - 자식 클래스 관계를 컴파일 시점에 결정하기 때문에 런타임에 객체의 종류를 변경하는데 제한이 생김

그래서 상속보다는 합성(composition)을 많이 쓴다~

합성은 다른 객체의 인스턴스를 자신 객체의 인스턴스 변수로 포함해서 재사용하는 것

또한, 인터페이스에 정의된 메시지를 통해서만 다른 객체의 코드를 재사용하는 방법